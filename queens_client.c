//queens_client.c
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "queens.h"
#include "uici.h"
#include "restart.h"

void * client_thread(void *point){

   struct ci * bar = point;
   int bytescopied;
   int communfd;
   char buf[128];
   char * q;
   char * s;

   //attempt to connect to server host
   if ((communfd = u_connect(bar->port, bar->host)) == -1) {
      perror("Failed to establish connection");
   }
   else{
      fprintf(stderr, "[%ld]:connection made to %s\n", (long)getpid(), bar->host);
      dprintf(communfd, "%d %d\n", bar->n, bar->first);

      /*read the lines generated by the servers and print them out on the
        client side*/
      while(readline(communfd, buf, 128) > 0){
         //we have to lock the mutex so output lines are not interleaved
         pthread_mutex_lock(&mutex);
         printf("%s", buf);
         pthread_mutex_unlock(&mutex);
         /*the result lines always start with a dollar sign so we parse them
           accordingly*/
         if(strncmp(buf, "$", 1) == 0){
           s = strtok_r(buf, " ", &q);
           s = strtok_r(NULL, " ", &q);
           s = strtok_r(NULL, " ", &q);
           s = strtok_r(NULL, " ", &q);
           bar->result = atoi(s);
         }
      }

      if (r_close(communfd) == -1) /* parent code */
         fprintf(stderr, "[%ld]:failed to close communfd: %s\n",
                          (long)getpid(), strerror(errno));
   }
}

int main(int argc, char *argv[]) {
   int ans;
   char buf;
   int bytescopied;
   FILE *fp;
   int communfd, i, lines, n;
   u_port_t portnumber;
   int s;

   //check for input sanity
   if (argc != 4){
      fprintf(stderr, "Usage: %s n file port\n", argv[0]);
      return 1;
   }
   portnumber = (u_port_t)atoi(argv[3]);
   n = atoi(argv[1]);

   //once we know n we know how many client threads we will need
   pthread_t t_c[n];
   struct ci my_info[n];

   printf("n = %d, port = %d\n", n, (int)portnumber);
   
   //open the textfile with the host list
   if((fp = fopen(argv[2], "r")) == NULL){
      printf("No such file\n");
      return -1;
   }

   /*we count the number of newlines so that we know how many hosts we will
     be using. This method assumes the file is properly formated with a 
     newline at the end of each ip address*/
   lines = 0;
   do{
      buf = fgetc(fp);
      if(buf == '\n')
        lines++;
   }
   while (buf != EOF);

   //reset the file for reading
   fseek(fp, 0, SEEK_SET);   

   //create our array of addresses
   char host[lines][20];

   //read the file line by line
   i = 0;
   while(fgets(host[i], 20, fp)){
      i++;
   }

   //we can close the fp now
   fclose(fp);


   //initialize thread
   for(i = 0; i < n; i++){
      //assign the values to use in the argument data structure
      my_info[i].n = n;
      my_info[i].first = i;
      strcpy(my_info[i].host, host[i%lines]);
      my_info[i].port = portnumber;
      /*each thread will have a result which is the number of found
        permutations*/
      my_info[i].result = 0;
      pthread_create(&(t_c[i]), NULL, client_thread, &(my_info[i]));
   }
         
   /*make sure that the process waits on all the threads it has
     made to finish and adds up the results to produce a total*/
   ans = 0;
   for(i = 0; i < n; i++){

      pthread_join(t_c[i], NULL);
      ans += my_info[i].result;
   }
   printf("n = %d, result = %d\n", n, ans);

   return 0;
}
